
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>parsers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maniartech/InternetObject-go/parsers/ast.go (0.0%)</option>
				
				<option value="file1">github.com/maniartech/InternetObject-go/parsers/constants.go (59.1%)</option>
				
				<option value="file2">github.com/maniartech/InternetObject-go/parsers/errors.go (0.0%)</option>
				
				<option value="file3">github.com/maniartech/InternetObject-go/parsers/position.go (20.0%)</option>
				
				<option value="file4">github.com/maniartech/InternetObject-go/parsers/token.go (15.4%)</option>
				
				<option value="file5">github.com/maniartech/InternetObject-go/parsers/tokenizer.go (48.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package parsers

// Node represents a node in the Abstract Syntax Tree.
// All AST nodes implement this interface for type safety and position tracking.
type Node interface {
        // GetStartPos returns the starting position of the node
        GetStartPos() Position
        // GetEndPos returns the ending position of the node
        GetEndPos() Position
        // NodeType returns the type of the node as a string
        NodeType() string
}

// BaseNode provides common functionality for all AST nodes.
type BaseNode struct {
        Position PositionRange
}

// GetStartPos implements the Node interface.
func (n *BaseNode) GetStartPos() Position <span class="cov0" title="0">{
        return n.Position.Start
}</span>

// GetEndPos implements the Node interface.
func (n *BaseNode) GetEndPos() Position <span class="cov0" title="0">{
        return n.Position.End
}</span>

// DocumentNode represents the root of an Internet Object document.
// It contains an optional header section and zero or more data sections.
type DocumentNode struct {
        BaseNode
        Header   *SectionNode   // Optional header section
        Sections []*SectionNode // Data sections
}

// NodeType returns the node type.
func (n *DocumentNode) NodeType() string <span class="cov0" title="0">{
        return "DocumentNode"
}</span>

// SectionNode represents a section in the document.
// Sections can have optional names and schema references.
type SectionNode struct {
        BaseNode
        Child      Node   // The content of the section (ObjectNode or CollectionNode)
        NameToken  *Token // Optional section name token
        SchemaNode *Token // Optional schema reference token
}

// NodeType returns the node type.
func (n *SectionNode) NodeType() string <span class="cov0" title="0">{
        return "SectionNode"
}</span>

// GetName returns the section name if present.
func (n *SectionNode) GetName() string <span class="cov0" title="0">{
        if n.NameToken != nil </span><span class="cov0" title="0">{
                if str, ok := n.NameToken.Value.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        // If no name token, try to get from schema node
        <span class="cov0" title="0">if n.SchemaNode != nil </span><span class="cov0" title="0">{
                if str, ok := n.SchemaNode.Value.(string); ok </span><span class="cov0" title="0">{
                        // Remove $ prefix
                        if len(str) &gt; 0 &amp;&amp; str[0] == '$' </span><span class="cov0" title="0">{
                                return str[1:]
                        }</span>
                        <span class="cov0" title="0">return str</span>
                }
        }
        <span class="cov0" title="0">return "unnamed"</span>
}

// GetSchemaName returns the schema name if present.
func (n *SectionNode) GetSchemaName() string <span class="cov0" title="0">{
        if n.SchemaNode != nil </span><span class="cov0" title="0">{
                if str, ok := n.SchemaNode.Value.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// CollectionNode represents a collection of objects (using ~ delimiter).
type CollectionNode struct {
        BaseNode
        Children []Node // Array of ObjectNode or ErrorNode
}

// NodeType returns the node type.
func (n *CollectionNode) NodeType() string <span class="cov0" title="0">{
        return "CollectionNode"
}</span>

// ObjectNode represents an object with key-value pairs or indexed values.
// It can be enclosed in {} or be an open object.
type ObjectNode struct {
        BaseNode
        Members      []*MemberNode // Array of members
        OpenBracket  *Token        // Optional opening bracket token
        CloseBracket *Token        // Optional closing bracket token
        IsOpen       bool          // True if this is an open object (no braces)
}

// NodeType returns the node type.
func (n *ObjectNode) NodeType() string <span class="cov0" title="0">{
        return "ObjectNode"
}</span>

// ArrayNode represents an array of values enclosed in [].
type ArrayNode struct {
        BaseNode
        Elements     []Node // Array elements
        OpenBracket  *Token // Opening bracket token
        CloseBracket *Token // Closing bracket token
}

// NodeType returns the node type.
func (n *ArrayNode) NodeType() string <span class="cov0" title="0">{
        return "ArrayNode"
}</span>

// MemberNode represents a key-value pair in an object.
// If Key is nil, it's an indexed value (array-like member).
type MemberNode struct {
        BaseNode
        Key   *Token // Optional key token
        Value Node   // Value (can be any node type)
}

// NodeType returns the node type.
func (n *MemberNode) NodeType() string <span class="cov0" title="0">{
        return "MemberNode"
}</span>

// HasKey returns true if this member has a key.
func (n *MemberNode) HasKey() bool <span class="cov0" title="0">{
        return n.Key != nil
}</span>

// TokenNode is a leaf node wrapping a single token.
// It represents primitive values (strings, numbers, booleans, etc.).
type TokenNode struct {
        BaseNode
        Token *Token
}

// NodeType returns the node type.
func (n *TokenNode) NodeType() string <span class="cov0" title="0">{
        return "TokenNode"
}</span>

// GetValue returns the token's value.
func (n *TokenNode) GetValue() interface{} <span class="cov0" title="0">{
        if n.Token != nil </span><span class="cov0" title="0">{
                return n.Token.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ErrorNode represents a parsing error embedded in the AST.
// This allows the parser to continue after errors and collect multiple errors.
type ErrorNode struct {
        BaseNode
        Error error // The error that occurred
}

// NodeType returns the node type.
func (n *ErrorNode) NodeType() string <span class="cov0" title="0">{
        return "ErrorNode"
}</span>

// NewDocumentNode creates a new document node.
func NewDocumentNode(header *SectionNode, sections []*SectionNode) *DocumentNode <span class="cov0" title="0">{
        var start, end Position

        if header != nil </span><span class="cov0" title="0">{
                start = header.GetStartPos()
        }</span> else<span class="cov0" title="0"> if len(sections) &gt; 0 </span><span class="cov0" title="0">{
                start = sections[0].GetStartPos()
        }</span>

        <span class="cov0" title="0">if len(sections) &gt; 0 </span><span class="cov0" title="0">{
                end = sections[len(sections)-1].GetEndPos()
        }</span> else<span class="cov0" title="0"> if header != nil </span><span class="cov0" title="0">{
                end = header.GetEndPos()
        }</span>

        <span class="cov0" title="0">return &amp;DocumentNode{
                BaseNode: BaseNode{Position: NewPositionRange(start, end)},
                Header:   header,
                Sections: sections,
        }</span>
}

// NewSectionNode creates a new section node.
func NewSectionNode(child Node, nameToken, schemaNode *Token) *SectionNode <span class="cov0" title="0">{
        var start, end Position

        if nameToken != nil </span><span class="cov0" title="0">{
                start = nameToken.GetStartPos()
        }</span> else<span class="cov0" title="0"> if schemaNode != nil </span><span class="cov0" title="0">{
                start = schemaNode.GetStartPos()
        }</span> else<span class="cov0" title="0"> if child != nil </span><span class="cov0" title="0">{
                start = child.GetStartPos()
        }</span>

        <span class="cov0" title="0">if child != nil </span><span class="cov0" title="0">{
                end = child.GetEndPos()
        }</span> else<span class="cov0" title="0"> if schemaNode != nil </span><span class="cov0" title="0">{
                end = schemaNode.GetEndPos()
        }</span> else<span class="cov0" title="0"> if nameToken != nil </span><span class="cov0" title="0">{
                end = nameToken.GetEndPos()
        }</span>

        <span class="cov0" title="0">return &amp;SectionNode{
                BaseNode:   BaseNode{Position: NewPositionRange(start, end)},
                Child:      child,
                NameToken:  nameToken,
                SchemaNode: schemaNode,
        }</span>
}

// NewCollectionNode creates a new collection node.
func NewCollectionNode(children []Node) *CollectionNode <span class="cov0" title="0">{
        var start, end Position
        if len(children) &gt; 0 </span><span class="cov0" title="0">{
                start = children[0].GetStartPos()
                end = children[len(children)-1].GetEndPos()
        }</span>

        <span class="cov0" title="0">return &amp;CollectionNode{
                BaseNode: BaseNode{Position: NewPositionRange(start, end)},
                Children: children,
        }</span>
}

// NewObjectNode creates a new object node.
func NewObjectNode(members []*MemberNode, openBracket, closeBracket *Token) *ObjectNode <span class="cov0" title="0">{
        var start, end Position
        isOpen := openBracket == nil

        if openBracket != nil </span><span class="cov0" title="0">{
                start = openBracket.GetStartPos()
        }</span> else<span class="cov0" title="0"> if len(members) &gt; 0 </span><span class="cov0" title="0">{
                start = members[0].GetStartPos()
        }</span>

        <span class="cov0" title="0">if closeBracket != nil </span><span class="cov0" title="0">{
                end = closeBracket.GetEndPos()
        }</span> else<span class="cov0" title="0"> if len(members) &gt; 0 </span><span class="cov0" title="0">{
                end = members[len(members)-1].GetEndPos()
        }</span>

        <span class="cov0" title="0">return &amp;ObjectNode{
                BaseNode:     BaseNode{Position: NewPositionRange(start, end)},
                Members:      members,
                OpenBracket:  openBracket,
                CloseBracket: closeBracket,
                IsOpen:       isOpen,
        }</span>
}

// NewArrayNode creates a new array node.
func NewArrayNode(elements []Node, openBracket, closeBracket *Token) *ArrayNode <span class="cov0" title="0">{
        start := openBracket.GetStartPos()
        end := closeBracket.GetEndPos()

        return &amp;ArrayNode{
                BaseNode:     BaseNode{Position: NewPositionRange(start, end)},
                Elements:     elements,
                OpenBracket:  openBracket,
                CloseBracket: closeBracket,
        }
}</span>

// NewMemberNode creates a new member node.
func NewMemberNode(value Node, key *Token) *MemberNode <span class="cov0" title="0">{
        var start, end Position

        if key != nil </span><span class="cov0" title="0">{
                start = key.GetStartPos()
        }</span> else<span class="cov0" title="0"> {
                start = value.GetStartPos()
        }</span>

        <span class="cov0" title="0">end = value.GetEndPos()

        return &amp;MemberNode{
                BaseNode: BaseNode{Position: NewPositionRange(start, end)},
                Key:      key,
                Value:    value,
        }</span>
}

// NewTokenNode creates a new token node.
func NewTokenNode(token *Token) *TokenNode <span class="cov0" title="0">{
        return &amp;TokenNode{
                BaseNode: BaseNode{Position: token.Position},
                Token:    token,
        }
}</span>

// NewErrorNode creates a new error node.
func NewErrorNode(err error, pos PositionRange) *ErrorNode <span class="cov0" title="0">{
        return &amp;ErrorNode{
                BaseNode: BaseNode{Position: pos},
                Error:    err,
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package parsers

// Literal constants for special values in Internet Object format
const (
        LiteralTrue  = "true"
        LiteralT     = "T"
        LiteralFalse = "false"
        LiteralF     = "F"
        LiteralNull  = "null"
        LiteralN     = "N"
        LiteralInf   = "Inf"
        LiteralNaN   = "NaN"
)

// Symbol constants for structural characters
const (
        SymbolCurlyOpen      = '{'
        SymbolCurlyClose     = '}'
        SymbolBracketOpen    = '['
        SymbolBracketClose   = ']'
        SymbolColon          = ':'
        SymbolComma          = ','
        SymbolTilde          = '~'
        SymbolMinus          = '-'
        SymbolPlus           = '+'
        SymbolDot            = '.'
        SymbolBackslash      = '\\'
        SymbolHash           = '#'
        SymbolDoubleQuote    = '"'
        SymbolSingleQuote    = '\''
        SymbolSpace          = ' '
        SymbolTab            = '\t'
        SymbolNewline        = '\n'
        SymbolCarriageReturn = '\r'
)

// Character classification constants
const (
        CharZero   = '0'
        CharNine   = '9'
        CharA      = 'a'
        CharF      = 'f'
        CharAUpper = 'A'
        CharFUpper = 'F'
        CharX      = 'x'
        CharXUpper = 'X'
        CharO      = 'o'
        CharOUpper = 'O'
        CharB      = 'b'
        CharBUpper = 'B'
        CharE      = 'e'
        CharEUpper = 'E'
        CharN      = 'n'
        CharM      = 'm'
        CharR      = 'r'
        CharD      = 'd'
        CharT      = 't'
        CharU      = 'u'
)

// Number format prefixes
const (
        PrefixHex       = "0x"
        PrefixHexAlt    = "0X"
        PrefixOctal     = "0o"
        PrefixOctalAlt  = "0O"
        PrefixBinary    = "0b"
        PrefixBinaryAlt = "0B"
)

// String annotation prefixes
const (
        AnnotationRaw      = "r"  // Raw string r"..."
        AnnotationByte     = "b"  // Byte/binary string b"..."
        AnnotationDateTime = "dt" // DateTime dt"..."
        AnnotationDate     = "d"  // Date d"..."
        AnnotationTime     = "t"  // Time t"..."
)

// Section separator
const SectionSeparator = "---"

// isDigit returns true if the character is a decimal digit (0-9).
func isDigit(ch rune) bool <span class="cov8" title="1">{
        return ch &gt;= CharZero &amp;&amp; ch &lt;= CharNine
}</span>

// isHexDigit returns true if the character is a hexadecimal digit (0-9, a-f, A-F).
func isHexDigit(ch rune) bool <span class="cov8" title="1">{
        return isDigit(ch) || (ch &gt;= CharA &amp;&amp; ch &lt;= CharF) || (ch &gt;= CharAUpper &amp;&amp; ch &lt;= CharFUpper)
}</span>

// isOctalDigit returns true if the character is an octal digit (0-7).
func isOctalDigit(ch rune) bool <span class="cov8" title="1">{
        return ch &gt;= CharZero &amp;&amp; ch &lt;= '7'
}</span>

// isBinaryDigit returns true if the character is a binary digit (0-1).
func isBinaryDigit(ch rune) bool <span class="cov8" title="1">{
        return ch == CharZero || ch == '1'
}</span>

// isWhitespace returns true if the character is whitespace.
// Matches the TypeScript implementation which includes:
// - ASCII whitespace and control characters (U+0000 to U+0020)
// - Non-breaking space (U+00A0)
// - Various Unicode spaces (U+2000-U+200A, U+2028, U+2029, etc.)
func isWhitespace(ch rune) bool <span class="cov8" title="1">{
        // Fast path: ASCII whitespace and control characters (U+0000 to U+0020)
        if ch &lt;= 0x20 </span><span class="cov8" title="1">{
                return true
        }</span>

        // Fast path: Extended ASCII range (U+0021 to U+00FF) - only U+00A0 is whitespace
        <span class="cov8" title="1">if ch &lt;= 0xFF </span><span class="cov8" title="1">{
                return ch == 0x00A0
        }</span>

        // Fast path: Anything above U+FEFF is never whitespace
        <span class="cov0" title="0">if ch &gt; 0xFEFF </span><span class="cov0" title="0">{
                return false
        }</span>

        // Fast path: Unicode range U+2000-U+200A (various em/en spaces)
        <span class="cov0" title="0">if ch &gt;= 0x2000 &amp;&amp; ch &lt;= 0x200A </span><span class="cov0" title="0">{
                return true
        }</span>

        // Lookup for remaining Unicode whitespace characters
        <span class="cov0" title="0">switch ch </span>{
        case 0x1680, // Ogham space mark
                0x2028, // Line separator
                0x2029, // Paragraph separator
                0x202F, // Narrow no-break space
                0x205F, // Medium mathematical space
                0x3000, // Ideographic space
                0xFEFF:<span class="cov0" title="0"> // BOM/Zero width no-break space
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// isHorizontalWhitespace returns true if the character is horizontal whitespace (space or tab).
func isHorizontalWhitespace(ch rune) bool <span class="cov8" title="1">{
        return ch == SymbolSpace || ch == SymbolTab
}</span>

// isSpecialSymbol returns true if the character is a special structural symbol.
func isSpecialSymbol(ch rune) bool <span class="cov8" title="1">{
        switch ch </span>{
        case SymbolCurlyOpen, SymbolCurlyClose, SymbolBracketOpen, SymbolBracketClose,
                SymbolColon, SymbolComma, SymbolTilde:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// isValidOpenStringChar returns true if the character is valid in an open string.
// Open strings cannot contain structural symbols or newlines.
func isValidOpenStringChar(ch rune) bool <span class="cov8" title="1">{
        return !isSpecialSymbol(ch) &amp;&amp; ch != SymbolNewline &amp;&amp; ch != SymbolCarriageReturn
}</span>

// isAlpha returns true if the character is an alphabetic character.
func isAlpha(ch rune) bool <span class="cov0" title="0">{
        return (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')
}</span>

// isAlphaNumeric returns true if the character is alphanumeric.
func isAlphaNumeric(ch rune) bool <span class="cov0" title="0">{
        return isAlpha(ch) || isDigit(ch)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package parsers

import (
        "fmt"
)

// ErrorCode represents a specific type of parsing error.
// These codes match the TypeScript implementation for consistency.
type ErrorCode string

// Error codes matching the TypeScript implementation
const (
        ErrorUnexpectedToken       ErrorCode = "unexpected-token"
        ErrorExpectingBracket      ErrorCode = "expecting-bracket"
        ErrorValueRequired         ErrorCode = "value-required"
        ErrorInvalidKey            ErrorCode = "invalid-key"
        ErrorStringNotClosed       ErrorCode = "string-not-closed"
        ErrorInvalidEscapeSeq      ErrorCode = "invalid-escape-sequence"
        ErrorInvalidDateTime       ErrorCode = "invalid-datetime"
        ErrorUnsupportedAnnotation ErrorCode = "unsupported-annotation"
        ErrorInvalidDefinition     ErrorCode = "invalid-definition"
        ErrorSchemaMissing         ErrorCode = "schema-missing"
        ErrorDuplicateSection      ErrorCode = "duplicate-section"
)

// IOError represents a base error in Internet Object parsing.
// It includes position information and error codes for precise error reporting.
type IOError struct {
        Code     ErrorCode     // Error code identifying the type of error
        Message  string        // Human-readable error message
        Position PositionRange // Position where the error occurred
        IsEOF    bool          // True if error occurred at end of file
}

// Error implements the error interface.
func (e *IOError) Error() string <span class="cov0" title="0">{
        if e.IsEOF </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %s at EOF", e.Code, e.Message)
        }</span>
        <span class="cov0" title="0">if e.Position.IsValid() </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %s at %s", e.Code, e.Message, e.Position.Start)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

// NewIOError creates a new IOError with the specified code and message.
func NewIOError(code ErrorCode, message string) *IOError <span class="cov0" title="0">{
        return &amp;IOError{
                Code:    code,
                Message: message,
                IsEOF:   false,
        }
}</span>

// NewIOErrorWithPos creates a new IOError with position information.
func NewIOErrorWithPos(code ErrorCode, message string, pos PositionRange) *IOError <span class="cov0" title="0">{
        return &amp;IOError{
                Code:     code,
                Message:  message,
                Position: pos,
                IsEOF:    false,
        }
}</span>

// NewIOErrorEOF creates a new IOError that occurred at end of file.
func NewIOErrorEOF(code ErrorCode, message string) *IOError <span class="cov0" title="0">{
        return &amp;IOError{
                Code:    code,
                Message: message,
                IsEOF:   true,
        }
}</span>

// SyntaxError represents a syntax error during parsing.
type SyntaxError struct {
        *IOError
}

// NewSyntaxError creates a new syntax error.
func NewSyntaxError(code ErrorCode, message string, pos PositionRange) *SyntaxError <span class="cov0" title="0">{
        return &amp;SyntaxError{
                IOError: NewIOErrorWithPos(code, message, pos),
        }
}</span>

// NewSyntaxErrorEOF creates a new syntax error at EOF.
func NewSyntaxErrorEOF(code ErrorCode, message string) *SyntaxError <span class="cov0" title="0">{
        return &amp;SyntaxError{
                IOError: NewIOErrorEOF(code, message),
        }
}</span>

// ValidationError represents a semantic validation error.
type ValidationError struct {
        *IOError
}

// NewValidationError creates a new validation error.
func NewValidationError(code ErrorCode, message string, pos PositionRange) *ValidationError <span class="cov0" title="0">{
        return &amp;ValidationError{
                IOError: NewIOErrorWithPos(code, message, pos),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package parsers

import "fmt"

// Position represents a specific location in the source code.
// It tracks both the byte offset and the human-readable row/column position.
type Position struct {
        Pos int // Byte offset in the source (0-indexed)
        Row int // Line number (1-indexed)
        Col int // Column number (1-indexed)
}

// PositionRange represents a range in the source code from start to end position.
// This is used to track the location of tokens and AST nodes.
type PositionRange struct {
        Start Position // Starting position
        End   Position // Ending position
}

// NewPosition creates a new Position at the specified location.
func NewPosition(pos, row, col int) Position <span class="cov8" title="1">{
        return Position{
                Pos: pos,
                Row: row,
                Col: col,
        }
}</span>

// NewPositionRange creates a new PositionRange with the given start and end positions.
func NewPositionRange(start, end Position) PositionRange <span class="cov8" title="1">{
        return PositionRange{
                Start: start,
                End:   end,
        }
}</span>

// String returns a human-readable representation of the position.
func (p Position) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d:%d", p.Row, p.Col)
}</span>

// String returns a human-readable representation of the position range.
func (pr PositionRange) String() string <span class="cov0" title="0">{
        if pr.Start.Row == pr.End.Row </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d:%d-%d", pr.Start.Row, pr.Start.Col, pr.End.Col)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d:%d-%d:%d", pr.Start.Row, pr.Start.Col, pr.End.Row, pr.End.Col)</span>
}

// IsValid returns true if the position has valid values.
func (p Position) IsValid() bool <span class="cov0" title="0">{
        return p.Pos &gt;= 0 &amp;&amp; p.Row &gt; 0 &amp;&amp; p.Col &gt; 0
}</span>

// IsValid returns true if the position range has valid positions.
func (pr PositionRange) IsValid() bool <span class="cov0" title="0">{
        return pr.Start.IsValid() &amp;&amp; pr.End.IsValid()
}</span>

// GetStartPos returns the starting position of the range.
// This provides compatibility with the Node interface.
func (pr PositionRange) GetStartPos() Position <span class="cov0" title="0">{
        return pr.Start
}</span>

// GetEndPos returns the ending position of the range.
// This provides compatibility with the Node interface.
func (pr PositionRange) GetEndPos() Position <span class="cov0" title="0">{
        return pr.End
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package parsers

// TokenType represents the type of a token in the Internet Object format.
// These types match the TypeScript implementation for consistency.
type TokenType string

// Token types - matching TypeScript implementation
const (
        // Structural tokens
        TokenCurlyOpen       TokenType = "CURLY_OPEN"
        TokenCurlyClose      TokenType = "CURLY_CLOSE"
        TokenBracketOpen     TokenType = "BRACKET_OPEN"
        TokenBracketClose    TokenType = "BRACKET_CLOSE"
        TokenColon           TokenType = "COLON"
        TokenComma           TokenType = "COMMA"
        TokenCollectionStart TokenType = "COLLECTION_START"
        TokenSectionSep      TokenType = "SECTION_SEP"

        // Value tokens
        TokenString    TokenType = "STRING"
        TokenNumber    TokenType = "NUMBER"
        TokenBigInt    TokenType = "BIGINT"
        TokenDecimal   TokenType = "DECIMAL"
        TokenBoolean   TokenType = "BOOLEAN"
        TokenNull      TokenType = "NULL"
        TokenUndefined TokenType = "UNDEFINED"
        TokenBinary    TokenType = "BINARY"

        // DateTime tokens
        TokenDateTime TokenType = "DATETIME"
        TokenDate     TokenType = "DATE"
        TokenTime     TokenType = "TIME"

        // Section tokens
        TokenSectionName   TokenType = "SECTION_NAME"
        TokenSectionSchema TokenType = "SECTION_SCHEMA"

        // Special tokens
        TokenWhitespace TokenType = "WHITESPACE"
        TokenUnknown    TokenType = "UNKNOWN"
        TokenError      TokenType = "ERROR"
)

// Token represents a lexical token in the Internet Object format.
// Tokens are immutable after creation for thread safety.
type Token struct {
        Type     TokenType     // Type of the token
        SubType  string        // Optional subtype (e.g., "RAW_STRING", "HEX", "OPEN_STRING")
        Value    interface{}   // Parsed value of the token
        Raw      string        // Raw text from source
        Position PositionRange // Position in source code
}

// NewToken creates a new token with the specified properties.
func NewToken(tokenType TokenType, value interface{}, raw string, pos PositionRange) *Token <span class="cov8" title="1">{
        return &amp;Token{
                Type:     tokenType,
                Value:    value,
                Raw:      raw,
                Position: pos,
        }
}</span>

// NewTokenWithSubType creates a new token with a subtype.
func NewTokenWithSubType(tokenType TokenType, subType string, value interface{}, raw string, pos PositionRange) *Token <span class="cov8" title="1">{
        return &amp;Token{
                Type:     tokenType,
                SubType:  subType,
                Value:    value,
                Raw:      raw,
                Position: pos,
        }
}</span>

// NewErrorToken creates an error token with error information.
func NewErrorToken(err error, raw string, pos PositionRange) *Token <span class="cov0" title="0">{
        return &amp;Token{
                Type:     TokenError,
                Value:    err,
                Raw:      raw,
                Position: pos,
        }
}</span>

// Clone creates a deep copy of the token.
// This is useful when a token needs to be modified (e.g., type conversion).
func (t *Token) Clone() *Token <span class="cov0" title="0">{
        return &amp;Token{
                Type:     t.Type,
                SubType:  t.SubType,
                Value:    t.Value,
                Raw:      t.Raw,
                Position: t.Position,
        }
}</span>

// IsError returns true if this is an error token.
func (t *Token) IsError() bool <span class="cov0" title="0">{
        return t.Type == TokenError
}</span>

// IsStructural returns true if this is a structural token (brackets, braces, etc.).
func (t *Token) IsStructural() bool <span class="cov0" title="0">{
        switch t.Type </span>{
        case TokenCurlyOpen, TokenCurlyClose, TokenBracketOpen, TokenBracketClose,
                TokenColon, TokenComma, TokenCollectionStart, TokenSectionSep:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsValue returns true if this is a value token.
func (t *Token) IsValue() bool <span class="cov0" title="0">{
        switch t.Type </span>{
        case TokenString, TokenNumber, TokenBigInt, TokenDecimal, TokenBoolean,
                TokenNull, TokenUndefined, TokenBinary, TokenDateTime, TokenDate, TokenTime:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetStartPos returns the starting position (implements PositionRange interface).
func (t *Token) GetStartPos() Position <span class="cov0" title="0">{
        return t.Position.Start
}</span>

// GetEndPos returns the ending position (implements PositionRange interface).
func (t *Token) GetEndPos() Position <span class="cov0" title="0">{
        return t.Position.End
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package parsers

import (
        "encoding/base64"
        "fmt"
        "math"
        "math/big"
        "regexp"
        "strconv"
        "strings"
        "time"
        "unicode/utf8"
)

// Tokenizer performs lexical analysis on Internet Object format input.
// It converts the input string into a sequence of tokens.
// The tokenizer is not thread-safe for concurrent use on the same instance,
// but multiple tokenizers can operate concurrently on different inputs.
type Tokenizer struct {
        input       string   // Input string to tokenize
        pos         int      // Current byte position
        row         int      // Current row (1-indexed)
        col         int      // Current column (1-indexed)
        reachedEnd  bool     // True if we've reached end of input
        inputLength int      // Cached input length
        tokens      []*Token // Collected tokens
}

// Regular expressions compiled once for performance
var (
        reHex4   = regexp.MustCompile(`^[0-9a-fA-F]{4}$`)
        reHex2   = regexp.MustCompile(`^[0-9a-fA-F]{2}$`)
        reBase64 = regexp.MustCompile(`^[A-Za-z0-9+/]*={0,2}$`)
        // Section name/schema pattern: matches "$schemaName: sectionName" or "$schemaName" or "sectionName: $schemaName"
        reSectionSchemaName = regexp.MustCompile(`^(?:(?:(?P&lt;name&gt;[\pL\pM\pN\-_]+)(?P&lt;sep&gt;[ \t]*:[ \t]*)?)(?P&lt;schema&gt;\$[\pL\pM\pN\-_]+)?|(?P&lt;schema2&gt;\$[\pL\pM\pN\-_]+))`)
        reAnnotatedStrStart = regexp.MustCompile(`^(?P&lt;name&gt;[a-zA-Z]{1,4})(?P&lt;quote&gt;['"])`)
)

// NewTokenizer creates a new tokenizer for the given input string.
func NewTokenizer(input string) *Tokenizer <span class="cov8" title="1">{
        return &amp;Tokenizer{
                input:       input,
                pos:         0,
                row:         1,
                col:         1,
                reachedEnd:  false,
                inputLength: len(input),
                tokens:      make([]*Token, 0, len(input)/8), // Pre-allocate estimated capacity
        }
}</span>

// Tokenize processes the entire input and returns all tokens.
// Returns an error if tokenization fails unrecoverably.
func (t *Tokenizer) Tokenize() ([]*Token, error) <span class="cov8" title="1">{
        for !t.reachedEnd </span><span class="cov8" title="1">{
                if !t.tokenizeNext() </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return t.tokens, nil</span>
}

// tokenizeNext processes the next token from the input.
// Returns false if end of input is reached, true otherwise.
func (t *Tokenizer) tokenizeNext() bool <span class="cov8" title="1">{
        if t.pos &gt;= t.inputLength </span><span class="cov0" title="0">{
                t.reachedEnd = true
                return false
        }</span>

        <span class="cov8" title="1">ch := rune(t.input[t.pos])

        // Whitespace - skip
        if isWhitespace(ch) </span><span class="cov8" title="1">{
                t.advance(1)
                return true
        }</span>

        // Single-line comments
        <span class="cov8" title="1">if ch == SymbolHash </span><span class="cov8" title="1">{
                t.parseSingleLineComment()
                return true
        }</span>

        // Regular strings
        <span class="cov8" title="1">if ch == SymbolDoubleQuote || ch == SymbolSingleQuote </span><span class="cov8" title="1">{
                token := t.parseRegularString(ch)
                t.tokens = append(t.tokens, token)
                return true
        }</span>

        // Special symbols
        <span class="cov8" title="1">if isSpecialSymbol(ch) </span><span class="cov8" title="1">{
                token := t.parseSpecialSymbol(ch)
                t.tokens = append(t.tokens, token)
                return true
        }</span>

        // Numbers
        <span class="cov8" title="1">if ch == SymbolPlus || ch == SymbolMinus || ch == SymbolDot || isDigit(ch) </span><span class="cov8" title="1">{
                // Check for section separator ---
                if ch == SymbolMinus &amp;&amp; t.pos+2 &lt; t.inputLength &amp;&amp;
                        t.input[t.pos:t.pos+3] == SectionSeparator </span><span class="cov8" title="1">{
                        t.parseSectionSeparator()
                        return true
                }</span>

                <span class="cov8" title="1">token := t.parseNumber()
                if token != nil </span><span class="cov8" title="1">{
                        // Check if number is followed by non-whitespace/non-symbol (making it an open string)
                        spaces := t.skipWhitespaces()
                        if !t.reachedEnd &amp;&amp; !isSpecialSymbol(rune(t.input[t.pos])) &amp;&amp; !isWhitespace(rune(t.input[t.pos])) </span><span class="cov0" title="0">{
                                nextToken := t.parseLiteralOrOpenString()
                                if nextToken != nil </span><span class="cov0" title="0">{
                                        // Merge tokens
                                        merged := t.mergeTokens(token, nextToken, spaces)
                                        t.tokens = append(t.tokens, merged)
                                        return true
                                }</span>
                        }
                        <span class="cov8" title="1">t.tokens = append(t.tokens, token)
                        return true</span>
                }

                // Not a number, try literal or open string
                <span class="cov0" title="0">token = t.parseLiteralOrOpenString()
                if token != nil </span><span class="cov0" title="0">{
                        t.tokens = append(t.tokens, token)
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        // Literals or open strings (including annotated strings)
        <span class="cov8" title="1">annotation := t.checkIfAnnotatedString()
        if annotation != nil </span><span class="cov0" title="0">{
                var token *Token
                switch annotation.name </span>{
                case AnnotationRaw:<span class="cov0" title="0">
                        token = t.parseRawString(annotation)</span>
                case AnnotationByte:<span class="cov0" title="0">
                        token = t.parseByteString(annotation)</span>
                case AnnotationDate, AnnotationDateTime, AnnotationTime:<span class="cov0" title="0">
                        token = t.parseDateTime(annotation)</span>
                default:<span class="cov0" title="0">
                        // Unsupported annotation - create error token
                        start := t.currentPosition()
                        msg := fmt.Sprintf("Unsupported annotation '%s'. Supported annotations are: 'r' (raw string), 'b' (binary), 'dt' (datetime), 'd' (date), 't' (time).", annotation.name)
                        err := NewSyntaxError(ErrorUnsupportedAnnotation, msg, start)
                        token = NewErrorToken(err, annotation.name+string(annotation.quote), start)
                        t.skipToNextTokenBoundary()</span>
                }
                <span class="cov0" title="0">t.tokens = append(t.tokens, token)
                return true</span>
        }

        // Regular literal or open string
        <span class="cov8" title="1">token := t.parseLiteralOrOpenString()
        if token != nil </span><span class="cov8" title="1">{
                t.tokens = append(t.tokens, token)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// currentPosition returns the current position as a PositionRange.
func (t *Tokenizer) currentPosition() PositionRange <span class="cov8" title="1">{
        pos := NewPosition(t.pos, t.row, t.col)
        return NewPositionRange(pos, pos)
}</span>

// advance moves the current position forward by the specified number of bytes.
// It properly tracks newlines for row/column counting.
func (t *Tokenizer) advance(count int) <span class="cov8" title="1">{
        for i := 0; i &lt; count &amp;&amp; t.pos &lt; t.inputLength; i++ </span><span class="cov8" title="1">{
                if t.input[t.pos] == SymbolNewline </span><span class="cov8" title="1">{
                        t.row++
                        t.col = 1
                }</span> else<span class="cov8" title="1"> {
                        t.col++
                }</span>
                <span class="cov8" title="1">t.pos++</span>
        }

        <span class="cov8" title="1">if t.pos &gt;= t.inputLength </span><span class="cov8" title="1">{
                t.reachedEnd = true
        }</span>
}

// peek returns the current rune without advancing.
// Returns 0 if at end of input.
func (t *Tokenizer) peek() rune <span class="cov0" title="0">{
        if t.reachedEnd || t.pos &gt;= t.inputLength </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">r, _ := utf8.DecodeRuneInString(t.input[t.pos:])
        return r</span>
}

// skipWhitespaces skips over whitespace characters and returns them as a string.
// This is used to handle whitespace normalization in strings.
func (t *Tokenizer) skipWhitespaces() string <span class="cov8" title="1">{
        start := t.pos
        for !t.reachedEnd &amp;&amp; isWhitespace(rune(t.input[t.pos])) </span><span class="cov8" title="1">{
                ch := t.input[t.pos]
                // Normalize \r\n or \r to \n
                if ch == SymbolCarriageReturn </span><span class="cov0" title="0">{
                        if t.pos+1 &lt; t.inputLength &amp;&amp; t.input[t.pos+1] == SymbolNewline </span><span class="cov0" title="0">{
                                t.advance(1)
                        }</span>
                        <span class="cov0" title="0">t.advance(1)</span>
                } else<span class="cov8" title="1"> {
                        t.advance(1)
                }</span>
        }

        <span class="cov8" title="1">if start == t.pos </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">spaces := t.input[start:t.pos]
        // Normalize \r sequences
        if strings.Contains(spaces, string(SymbolCarriageReturn)) </span><span class="cov0" title="0">{
                spaces = strings.ReplaceAll(spaces, "\r\n", "\n")
                spaces = strings.ReplaceAll(spaces, "\r", "\n")
        }</span>
        <span class="cov8" title="1">return spaces</span>
}

// skipToNextTokenBoundary skips characters until a token boundary is found.
// This is used for error recovery.
func (t *Tokenizer) skipToNextTokenBoundary() <span class="cov0" title="0">{
        for !t.reachedEnd &amp;&amp; !isWhitespace(rune(t.input[t.pos])) &amp;&amp;
                !isSpecialSymbol(rune(t.input[t.pos])) &amp;&amp;
                t.input[t.pos] != SymbolComma &amp;&amp;
                t.input[t.pos] != SymbolNewline </span><span class="cov0" title="0">{
                t.advance(1)
        }</span>
}

// parseSingleLineComment skips over a single-line comment (from # to end of line).
func (t *Tokenizer) parseSingleLineComment() <span class="cov8" title="1">{
        for !t.reachedEnd &amp;&amp; t.input[t.pos] != SymbolNewline </span><span class="cov8" title="1">{
                t.advance(1)
        }</span>
}

// parseSpecialSymbol parses a structural symbol token.
func (t *Tokenizer) parseSpecialSymbol(ch rune) *Token <span class="cov8" title="1">{
        start := t.currentPosition()
        raw := string(ch)
        t.advance(1)

        var tokenType TokenType
        switch ch </span>{
        case SymbolCurlyOpen:<span class="cov8" title="1">
                tokenType = TokenCurlyOpen</span>
        case SymbolCurlyClose:<span class="cov8" title="1">
                tokenType = TokenCurlyClose</span>
        case SymbolBracketOpen:<span class="cov8" title="1">
                tokenType = TokenBracketOpen</span>
        case SymbolBracketClose:<span class="cov8" title="1">
                tokenType = TokenBracketClose</span>
        case SymbolColon:<span class="cov8" title="1">
                tokenType = TokenColon</span>
        case SymbolComma:<span class="cov8" title="1">
                tokenType = TokenComma</span>
        case SymbolTilde:<span class="cov8" title="1">
                tokenType = TokenCollectionStart</span>
        default:<span class="cov0" title="0">
                tokenType = TokenUnknown</span>
        }

        <span class="cov8" title="1">end := t.currentPosition()
        return NewToken(tokenType, raw, raw, NewPositionRange(start.Start, end.Start))</span>
}

// parseRegularString parses a quoted string (single or double quoted).
func (t *Tokenizer) parseRegularString(encloser rune) *Token <span class="cov8" title="1">{
        start := t.currentPosition()
        startPos := t.pos

        t.advance(1) // Skip opening quote
        var value strings.Builder
        needToNormalize := false

        for !t.reachedEnd &amp;&amp; rune(t.input[t.pos]) != encloser </span><span class="cov8" title="1">{
                if isWhitespace(rune(t.input[t.pos])) </span><span class="cov8" title="1">{
                        spaces := t.skipWhitespaces()
                        value.WriteString(spaces)
                        continue</span>
                }

                // Handle escape sequences
                <span class="cov8" title="1">if t.input[t.pos] == SymbolBackslash </span><span class="cov8" title="1">{
                        escaped, normalize, err := t.escapeString()
                        if err != nil </span><span class="cov0" title="0">{
                                // For invalid escape sequences, treat as literal
                                if !t.reachedEnd </span><span class="cov0" title="0">{
                                        escapeChar := t.input[t.pos]
                                        value.WriteByte(escapeChar)
                                        t.advance(1)

                                        // Handle \u and \x sequences
                                        if escapeChar == CharU </span><span class="cov0" title="0">{
                                                for i := 0; i &lt; 4 &amp;&amp; !t.reachedEnd; i++ </span><span class="cov0" title="0">{
                                                        value.WriteByte(t.input[t.pos])
                                                        t.advance(1)
                                                }</span>
                                        } else<span class="cov0" title="0"> if escapeChar == 'x' </span><span class="cov0" title="0">{
                                                for i := 0; i &lt; 2 &amp;&amp; !t.reachedEnd; i++ </span><span class="cov0" title="0">{
                                                        value.WriteByte(t.input[t.pos])
                                                        t.advance(1)
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov8" title="1">value.WriteString(escaped)
                        if normalize </span><span class="cov0" title="0">{
                                needToNormalize = true
                        }</span>
                } else<span class="cov8" title="1"> {
                        value.WriteByte(t.input[t.pos])
                        t.advance(1)
                }</span>
        }

        // Check for unclosed string
        <span class="cov8" title="1">if t.reachedEnd </span><span class="cov0" title="0">{
                raw := t.input[startPos:t.pos]
                end := t.currentPosition()
                err := NewSyntaxErrorEOF(ErrorStringNotClosed, "Unterminated string literal. Expected closing quote before end of input.")
                return NewErrorToken(err, raw, NewPositionRange(start.Start, end.Start))
        }</span>

        <span class="cov8" title="1">t.advance(1) // Skip closing quote

        raw := t.input[startPos:t.pos]
        finalValue := value.String()

        // Normalize if needed (NFC normalization for Unicode)
        if needToNormalize </span>{<span class="cov0" title="0">
                // Go strings are already UTF-8, NFC normalization would require unicode/norm package
                // For now, skip normalization to keep dependencies minimal
        }</span>

        <span class="cov8" title="1">end := t.currentPosition()
        return NewTokenWithSubType(TokenString, "REGULAR_STRING", finalValue, raw, NewPositionRange(start.Start, end.Start))</span>
}

// escapeString processes an escape sequence starting at current position (after backslash).
// Returns the escaped string, whether normalization is needed, and any error.
func (t *Tokenizer) escapeString() (string, bool, error) <span class="cov8" title="1">{
        t.advance(1) // Skip backslash
        if t.reachedEnd </span><span class="cov0" title="0">{
                return "", false, NewSyntaxErrorEOF(ErrorInvalidEscapeSeq, "Invalid escape sequence at end of input. Expected escape character after backslash.")
        }</span>

        <span class="cov8" title="1">ch := t.input[t.pos]
        t.advance(1)

        switch ch </span>{
        case 'b':<span class="cov0" title="0">
                return "\b", false, nil</span>
        case 'f':<span class="cov0" title="0">
                return "\f", false, nil</span>
        case 'n':<span class="cov8" title="1">
                return "\n", false, nil</span>
        case 'r':<span class="cov0" title="0">
                return "\r", false, nil</span>
        case 't':<span class="cov8" title="1">
                return "\t", false, nil</span>
        case CharU:<span class="cov0" title="0">
                // Unicode escape \uXXXX
                if t.pos+4 &gt; t.inputLength </span><span class="cov0" title="0">{
                        return "", false, NewSyntaxError(ErrorInvalidEscapeSeq, "Invalid Unicode escape sequence. Expected 4 hexadecimal digits.", t.currentPosition())
                }</span>
                <span class="cov0" title="0">hex := t.input[t.pos : t.pos+4]
                if !reHex4.MatchString(hex) </span><span class="cov0" title="0">{
                        return "", false, NewSyntaxError(ErrorInvalidEscapeSeq, fmt.Sprintf("Invalid Unicode escape sequence '\\u%s'. Expected 4 hexadecimal digits (0-9, A-F).", hex), t.currentPosition())
                }</span>
                <span class="cov0" title="0">val, _ := strconv.ParseInt(hex, 16, 32)
                t.advance(4)
                return string(rune(val)), true, nil</span>
        case 'x':<span class="cov0" title="0">
                // Hex escape \xXX
                if t.pos+2 &gt; t.inputLength </span><span class="cov0" title="0">{
                        return "", false, NewSyntaxError(ErrorInvalidEscapeSeq, "Invalid hexadecimal escape sequence. Expected 2 hexadecimal digits.", t.currentPosition())
                }</span>
                <span class="cov0" title="0">hex := t.input[t.pos : t.pos+2]
                if !reHex2.MatchString(hex) </span><span class="cov0" title="0">{
                        return "", false, NewSyntaxError(ErrorInvalidEscapeSeq, fmt.Sprintf("Invalid hexadecimal escape sequence '\\x%s'. Expected 2 hexadecimal digits (0-9, A-F).", hex), t.currentPosition())
                }</span>
                <span class="cov0" title="0">val, _ := strconv.ParseInt(hex, 16, 32)
                t.advance(2)
                return string(rune(val)), true, nil</span>
        default:<span class="cov8" title="1">
                // Treat unrecognized escape as literal character
                return string(ch), false, nil</span>
        }
}

// Annotation holds information about an annotated string prefix.
type Annotation struct {
        name  string
        quote rune
}

// checkIfAnnotatedString checks if the current position starts an annotated string.
// Returns annotation information if found, nil otherwise.
func (t *Tokenizer) checkIfAnnotatedString() *Annotation <span class="cov8" title="1">{
        if t.pos+2 &gt; t.inputLength </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">match := reAnnotatedStrStart.FindStringSubmatch(t.input[t.pos:])
        if match == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">nameIdx := reAnnotatedStrStart.SubexpIndex("name")
        quoteIdx := reAnnotatedStrStart.SubexpIndex("quote")

        if nameIdx &lt; 0 || quoteIdx &lt; 0 || nameIdx &gt;= len(match) || quoteIdx &gt;= len(match) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;Annotation{
                name:  match[nameIdx],
                quote: rune(match[quoteIdx][0]),
        }</span>
}

// parseAnnotatedString parses an annotated string (e.g., r"...", b"...", dt"...").
func (t *Tokenizer) parseAnnotatedString(annotation *Annotation) *Token <span class="cov0" title="0">{
        start := t.currentPosition()
        startPos := t.pos

        // Skip annotation prefix
        t.advance(len(annotation.name))
        t.advance(1) // Skip opening quote

        // Read until closing quote
        for !t.reachedEnd &amp;&amp; rune(t.input[t.pos]) != annotation.quote </span><span class="cov0" title="0">{
                t.advance(1)
        }</span>

        <span class="cov0" title="0">raw := t.input[startPos:t.pos]
        var value string

        if t.reachedEnd </span><span class="cov0" title="0">{
                // Unclosed annotated string - extract what we have
                value = t.input[startPos+len(annotation.name)+1 : t.pos]
        }</span> else<span class="cov0" title="0"> {
                t.advance(1) // Skip closing quote
                fullRaw := t.input[startPos:t.pos]
                value = fullRaw[len(annotation.name)+1 : len(fullRaw)-1]
                raw = fullRaw
        }</span>

        <span class="cov0" title="0">end := t.currentPosition()
        token := NewToken(TokenString, value, raw, NewPositionRange(start.Start, end.Start))
        return token</span>
}

// parseRawString parses a raw string (r"...").
func (t *Tokenizer) parseRawString(annotation *Annotation) *Token <span class="cov0" title="0">{
        token := t.parseAnnotatedString(annotation)
        if token.Type == TokenError </span><span class="cov0" title="0">{
                return token
        }</span>
        <span class="cov0" title="0">token.SubType = "RAW_STRING"
        return token</span>
}

// parseByteString parses a byte/binary string (b"...").
func (t *Tokenizer) parseByteString(annotation *Annotation) *Token <span class="cov0" title="0">{
        token := t.parseAnnotatedString(annotation)
        if token.Type == TokenError </span><span class="cov0" title="0">{
                return token
        }</span>

        // Validate and decode base64
        <span class="cov0" title="0">valueStr, ok := token.Value.(string)
        if !ok </span><span class="cov0" title="0">{
                return token
        }</span>

        <span class="cov0" title="0">if !reBase64.MatchString(valueStr) </span><span class="cov0" title="0">{
                err := NewSyntaxError(ErrorInvalidEscapeSeq, "Invalid base64 format in byte string", token.Position)
                return NewErrorToken(err, token.Raw, token.Position)
        }</span>

        <span class="cov0" title="0">decoded, err := base64.StdEncoding.DecodeString(valueStr)
        if err != nil </span><span class="cov0" title="0">{
                syntaxErr := NewSyntaxError(ErrorInvalidEscapeSeq, fmt.Sprintf("Invalid base64 encoding: %v", err), token.Position)
                return NewErrorToken(syntaxErr, token.Raw, token.Position)
        }</span>

        <span class="cov0" title="0">token.Type = TokenBinary
        token.SubType = "BINARY_STRING"
        token.Value = decoded
        return token</span>
}

// parseDateTime parses a datetime, date, or time string (dt"...", d"...", t"...").
func (t *Tokenizer) parseDateTime(annotation *Annotation) *Token <span class="cov0" title="0">{
        token := t.parseAnnotatedString(annotation)
        if token.Type == TokenError </span><span class="cov0" title="0">{
                return token
        }</span>

        <span class="cov0" title="0">valueStr, ok := token.Value.(string)
        if !ok </span><span class="cov0" title="0">{
                return token
        }</span>

        <span class="cov0" title="0">var parsedTime time.Time
        var parseErr error

        switch annotation.name </span>{
        case AnnotationDateTime:<span class="cov0" title="0">
                parsedTime, parseErr = time.Parse(time.RFC3339, valueStr)
                token.SubType = "DATETIME"</span>
        case AnnotationDate:<span class="cov0" title="0">
                parsedTime, parseErr = time.Parse("2006-01-02", valueStr)
                token.SubType = "DATE"</span>
        case AnnotationTime:<span class="cov0" title="0">
                parsedTime, parseErr = time.Parse("15:04:05", valueStr)
                token.SubType = "TIME"</span>
        }

        <span class="cov0" title="0">if parseErr != nil </span><span class="cov0" title="0">{
                typeName := "datetime"
                if annotation.name == AnnotationDate </span><span class="cov0" title="0">{
                        typeName = "date"
                }</span> else<span class="cov0" title="0"> if annotation.name == AnnotationTime </span><span class="cov0" title="0">{
                        typeName = "time"
                }</span>
                <span class="cov0" title="0">msg := fmt.Sprintf("Invalid %s format '%s'. Expected valid ISO 8601 format.", typeName, valueStr)
                err := NewSyntaxError(ErrorInvalidDateTime, msg, token.Position)
                return NewErrorToken(err, token.Raw, token.Position)</span>
        }

        <span class="cov0" title="0">token.Type = TokenDateTime
        token.Value = parsedTime
        return token</span>
}

// parseNumber parses a numeric literal (integer, float, hex, octal, binary, BigInt, Decimal, Inf, NaN).
func (t *Tokenizer) parseNumber() *Token <span class="cov8" title="1">{
        start := t.currentPosition()
        startPos := t.pos

        var rawValue strings.Builder
        base := 10
        hasDecimal := false
        hasExponent := false
        prefix := ""
        var subType string

        // Handle sign
        if t.input[t.pos] == SymbolPlus || t.input[t.pos] == SymbolMinus </span><span class="cov8" title="1">{
                sign := string(t.input[t.pos])

                // Check for Infinity
                if t.pos+4 &lt;= t.inputLength &amp;&amp; t.input[t.pos+1:t.pos+4] == "Inf" </span><span class="cov0" title="0">{
                        t.advance(4)
                        end := t.currentPosition()
                        val := math.Inf(1) // +Inf
                        if sign == "-" </span><span class="cov0" title="0">{
                                val = math.Inf(-1) // -Inf
                        }</span>
                        <span class="cov0" title="0">raw := t.input[startPos:t.pos]
                        return NewToken(TokenNumber, val, raw, NewPositionRange(start.Start, end.Start))</span>
                }

                // Allow sign only if followed by digit or dot
                <span class="cov8" title="1">if t.pos+1 &lt; t.inputLength &amp;&amp; (isDigit(rune(t.input[t.pos+1])) || t.input[t.pos+1] == SymbolDot) </span><span class="cov8" title="1">{
                        rawValue.WriteString(sign)
                        t.advance(1)
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        } else<span class="cov8" title="1"> if t.pos+3 &lt;= t.inputLength &amp;&amp; t.input[t.pos:t.pos+3] == "Inf" </span><span class="cov0" title="0">{
                // Infinity without sign
                t.advance(3)
                end := t.currentPosition()
                raw := t.input[startPos:t.pos]
                return NewToken(TokenNumber, math.Inf(1), raw, NewPositionRange(start.Start, end.Start))
        }</span>

        // Check for leading dot (decimal number starting with .)
        <span class="cov8" title="1">if t.input[t.pos] == SymbolDot </span><span class="cov0" title="0">{
                if t.pos+1 &gt;= t.inputLength || !isDigit(rune(t.input[t.pos+1])) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Determine number format (hex, octal, binary, or decimal)
        <span class="cov8" title="1">if t.input[t.pos] == CharZero &amp;&amp; t.pos+1 &lt; t.inputLength </span><span class="cov8" title="1">{
                next := t.input[t.pos+1]
                switch next </span>{
                case CharX, CharXUpper:<span class="cov8" title="1">
                        base = 16
                        subType = "HEX"
                        prefix = t.input[t.pos : t.pos+2]
                        t.advance(2)
                        for !t.reachedEnd &amp;&amp; isHexDigit(rune(t.input[t.pos])) </span><span class="cov8" title="1">{
                                rawValue.WriteByte(t.input[t.pos])
                                t.advance(1)
                        }</span>
                case CharO, CharOUpper:<span class="cov8" title="1">
                        base = 8
                        subType = "OCTAL"
                        prefix = t.input[t.pos : t.pos+2]
                        t.advance(2)
                        for !t.reachedEnd &amp;&amp; isOctalDigit(rune(t.input[t.pos])) </span><span class="cov8" title="1">{
                                rawValue.WriteByte(t.input[t.pos])
                                t.advance(1)
                        }</span>
                case CharB, CharBUpper:<span class="cov8" title="1">
                        base = 2
                        subType = "BINARY"
                        prefix = t.input[t.pos : t.pos+2]
                        t.advance(2)
                        for !t.reachedEnd &amp;&amp; isBinaryDigit(rune(t.input[t.pos])) </span><span class="cov8" title="1">{
                                rawValue.WriteByte(t.input[t.pos])
                                t.advance(1)
                        }</span>
                default:<span class="cov0" title="0">
                        // Regular decimal number
                        for !t.reachedEnd &amp;&amp; isDigit(rune(t.input[t.pos])) </span><span class="cov0" title="0">{
                                rawValue.WriteByte(t.input[t.pos])
                                t.advance(1)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Parse whole part
                for !t.reachedEnd &amp;&amp; isDigit(rune(t.input[t.pos])) </span><span class="cov8" title="1">{
                        rawValue.WriteByte(t.input[t.pos])
                        t.advance(1)
                }</span>
        }

        // Parse decimal point and fractional part (only for base 10)
        <span class="cov8" title="1">if base == 10 &amp;&amp; !t.reachedEnd &amp;&amp; t.input[t.pos] == SymbolDot </span><span class="cov8" title="1">{
                hasDecimal = true
                rawValue.WriteByte(SymbolDot)
                t.advance(1)
                for !t.reachedEnd &amp;&amp; isDigit(rune(t.input[t.pos])) </span><span class="cov8" title="1">{
                        rawValue.WriteByte(t.input[t.pos])
                        t.advance(1)
                }</span>
        }

        // Parse exponent (e.g., e10, E-5)
        <span class="cov8" title="1">if base == 10 &amp;&amp; !t.reachedEnd &amp;&amp; (t.input[t.pos] == CharE || t.input[t.pos] == CharEUpper) </span><span class="cov0" title="0">{
                hasExponent = true
                rawValue.WriteByte(t.input[t.pos])
                t.advance(1)
                if !t.reachedEnd &amp;&amp; (t.input[t.pos] == SymbolPlus || t.input[t.pos] == SymbolMinus) </span><span class="cov0" title="0">{
                        rawValue.WriteByte(t.input[t.pos])
                        t.advance(1)
                }</span>
                <span class="cov0" title="0">for !t.reachedEnd &amp;&amp; isDigit(rune(t.input[t.pos])) </span><span class="cov0" title="0">{
                        rawValue.WriteByte(t.input[t.pos])
                        t.advance(1)
                }</span>
        }

        <span class="cov8" title="1">rawStr := rawValue.String()
        if rawStr == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var tokenType TokenType = TokenNumber
        var value interface{}
        end := t.currentPosition()

        // Check for BigInt suffix 'n'
        if !t.reachedEnd &amp;&amp; t.input[t.pos] == CharN </span><span class="cov0" title="0">{
                tokenType = TokenBigInt
                t.advance(1)
                // Parse as big.Int
                bigInt := new(big.Int)
                _, success := bigInt.SetString(prefix+rawStr, base)
                if !success </span><span class="cov0" title="0">{
                        err := NewSyntaxError(ErrorUnexpectedToken, fmt.Sprintf("Invalid BigInt literal: %s", prefix+rawStr), NewPositionRange(start.Start, end.Start))
                        raw := t.input[startPos:t.pos]
                        return NewErrorToken(err, raw, NewPositionRange(start.Start, end.Start))
                }</span>
                <span class="cov0" title="0">value = bigInt</span>
        } else<span class="cov8" title="1"> if !t.reachedEnd &amp;&amp; t.input[t.pos] == CharM </span><span class="cov0" title="0">{
                // Decimal suffix 'm' - for now treat as float64
                // A full implementation would use a decimal library
                tokenType = TokenDecimal
                t.advance(1)
                val, err := strconv.ParseFloat(rawStr, 64)
                if err != nil </span><span class="cov0" title="0">{
                        syntaxErr := NewSyntaxError(ErrorUnexpectedToken, fmt.Sprintf("Invalid decimal literal: %s", rawStr), NewPositionRange(start.Start, end.Start))
                        raw := t.input[startPos:t.pos]
                        return NewErrorToken(syntaxErr, raw, NewPositionRange(start.Start, end.Start))
                }</span>
                <span class="cov0" title="0">value = val</span>
        } else<span class="cov8" title="1"> {
                // Regular number
                if base == 10 &amp;&amp; (hasDecimal || hasExponent) </span><span class="cov8" title="1">{
                        val, err := strconv.ParseFloat(rawStr, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                syntaxErr := NewSyntaxError(ErrorUnexpectedToken, fmt.Sprintf("Invalid number: %s", rawStr), NewPositionRange(start.Start, end.Start))
                                raw := t.input[startPos:t.pos]
                                return NewErrorToken(syntaxErr, raw, NewPositionRange(start.Start, end.Start))
                        }</span>
                        <span class="cov8" title="1">value = val</span>
                } else<span class="cov8" title="1"> {
                        val, err := strconv.ParseInt(rawStr, base, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                syntaxErr := NewSyntaxError(ErrorUnexpectedToken, fmt.Sprintf("Invalid integer: %s", rawStr), NewPositionRange(start.Start, end.Start))
                                raw := t.input[startPos:t.pos]
                                return NewErrorToken(syntaxErr, raw, NewPositionRange(start.Start, end.Start))
                        }</span>
                        <span class="cov8" title="1">value = val</span>
                }
        }

        <span class="cov8" title="1">end = t.currentPosition()
        raw := t.input[startPos:t.pos]
        if subType != "" </span><span class="cov8" title="1">{
                return NewTokenWithSubType(tokenType, subType, value, raw, NewPositionRange(start.Start, end.Start))
        }</span>
        <span class="cov8" title="1">return NewToken(tokenType, value, raw, NewPositionRange(start.Start, end.Start))</span>
}

// parseLiteralOrOpenString parses a literal value (true, false, null, NaN) or an open string.
func (t *Tokenizer) parseLiteralOrOpenString() *Token <span class="cov8" title="1">{
        start := t.currentPosition()
        startPos := t.pos

        var value strings.Builder

        for !t.reachedEnd &amp;&amp; isValidOpenStringChar(rune(t.input[t.pos])) </span><span class="cov8" title="1">{
                ch := t.input[t.pos]

                if isWhitespace(rune(ch)) </span><span class="cov8" title="1">{
                        spaces := t.skipWhitespaces()
                        value.WriteString(spaces)
                        continue</span>
                }

                // Check for section separator
                <span class="cov8" title="1">if ch == SymbolMinus &amp;&amp; t.pos+2 &lt; t.inputLength &amp;&amp; t.input[t.pos:t.pos+3] == SectionSeparator </span><span class="cov0" title="0">{
                        break</span>
                }

                // Handle escape sequences
                // Handle escape sequences
                <span class="cov8" title="1">if ch == SymbolBackslash </span><span class="cov0" title="0">{
                        escaped, _, err := t.escapeString()
                        if err != nil </span><span class="cov0" title="0">{
                                // For open strings, preserve backslash and character
                                value.WriteByte(SymbolBackslash)
                                if !t.reachedEnd </span><span class="cov0" title="0">{
                                        escapeChar := t.input[t.pos]
                                        value.WriteByte(escapeChar)
                                        t.advance(1)

                                        if escapeChar == CharU </span><span class="cov0" title="0">{
                                                for i := 0; i &lt; 4 &amp;&amp; !t.reachedEnd; i++ </span><span class="cov0" title="0">{
                                                        value.WriteByte(t.input[t.pos])
                                                        t.advance(1)
                                                }</span>
                                        } else<span class="cov0" title="0"> if escapeChar == 'x' </span><span class="cov0" title="0">{
                                                for i := 0; i &lt; 2 &amp;&amp; !t.reachedEnd; i++ </span><span class="cov0" title="0">{
                                                        value.WriteByte(t.input[t.pos])
                                                        t.advance(1)
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">value.WriteString(escaped)</span>
                } else<span class="cov8" title="1"> {
                        value.WriteByte(ch)
                        t.advance(1)
                }</span>
        }

        <span class="cov8" title="1">str := strings.TrimRight(value.String(), " \t")
        if str == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // if needToNormalize {
        //         // Unicode normalization would go here
        // }

        <span class="cov8" title="1">end := t.currentPosition()
        raw := t.input[startPos:t.pos]
        pos := NewPositionRange(start.Start, end.Start)

        // Check for literals
        switch str </span>{
        case LiteralTrue, LiteralT:<span class="cov8" title="1">
                return NewToken(TokenBoolean, true, raw, pos)</span>
        case LiteralFalse, LiteralF:<span class="cov8" title="1">
                return NewToken(TokenBoolean, false, raw, pos)</span>
        case LiteralNull, LiteralN:<span class="cov8" title="1">
                return NewToken(TokenNull, nil, raw, pos)</span>
        case LiteralInf:<span class="cov0" title="0">
                return NewToken(TokenNumber, math.Inf(1), raw, pos)</span>
        case LiteralNaN:<span class="cov0" title="0">
                return NewToken(TokenNumber, math.NaN(), raw, pos)</span>
        default:<span class="cov8" title="1">
                return NewTokenWithSubType(TokenString, "OPEN_STRING", str, raw, pos)</span>
        }
}

// parseSectionSeparator parses a section separator (---) and optional section name/schema.
func (t *Tokenizer) parseSectionSeparator() <span class="cov8" title="1">{
        start := t.currentPosition()

        // Parse ---
        t.advance(3)
        end := t.currentPosition()
        sepToken := NewToken(TokenSectionSep, SectionSeparator, SectionSeparator, NewPositionRange(start.Start, end.Start))
        t.tokens = append(t.tokens, sepToken)

        // Skip horizontal whitespace
        for !t.reachedEnd &amp;&amp; isHorizontalWhitespace(rune(t.input[t.pos])) </span><span class="cov8" title="1">{
                t.advance(1)
        }</span>

        // Try to match section name and/or schema
        <span class="cov8" title="1">if t.reachedEnd </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">match := reSectionSchemaName.FindStringSubmatchIndex(t.input[t.pos:])
        if match == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">nameIdx := reSectionSchemaName.SubexpIndex("name")
        schemaIdx := reSectionSchemaName.SubexpIndex("schema")
        schema2Idx := reSectionSchemaName.SubexpIndex("schema2")
        sepIdx := reSectionSchemaName.SubexpIndex("sep")

        // Extract matched groups
        var name, schema, schema2, sep string
        if nameIdx &gt;= 0 &amp;&amp; match[nameIdx*2] &gt;= 0 </span><span class="cov8" title="1">{
                name = t.input[t.pos+match[nameIdx*2] : t.pos+match[nameIdx*2+1]]
        }</span>
        <span class="cov8" title="1">if schemaIdx &gt;= 0 &amp;&amp; match[schemaIdx*2] &gt;= 0 </span><span class="cov0" title="0">{
                schema = t.input[t.pos+match[schemaIdx*2] : t.pos+match[schemaIdx*2+1]]
        }</span>
        <span class="cov8" title="1">if schema2Idx &gt;= 0 &amp;&amp; match[schema2Idx*2] &gt;= 0 </span><span class="cov0" title="0">{
                schema2 = t.input[t.pos+match[schema2Idx*2] : t.pos+match[schema2Idx*2+1]]
        }</span>
        <span class="cov8" title="1">if sepIdx &gt;= 0 &amp;&amp; match[sepIdx*2] &gt;= 0 </span><span class="cov0" title="0">{
                sep = t.input[t.pos+match[sepIdx*2] : t.pos+match[sepIdx*2+1]]
        }</span>

        // When only schema2 is present, it's the schema
        <span class="cov8" title="1">if schema2 != "" </span><span class="cov0" title="0">{
                start := t.currentPosition()
                t.advance(len(schema2))
                end := t.currentPosition()
                token := NewTokenWithSubType(TokenString, string(TokenSectionSchema), schema2, schema2, NewPositionRange(start.Start, end.Start))
                t.tokens = append(t.tokens, token)
                t.skipWhitespaces()
                return
        }</span>

        // Parse name if present
        <span class="cov8" title="1">if name != "" </span><span class="cov8" title="1">{
                start := t.currentPosition()
                t.advance(len(name))
                end := t.currentPosition()
                token := NewTokenWithSubType(TokenString, string(TokenSectionName), name, name, NewPositionRange(start.Start, end.Start))
                t.tokens = append(t.tokens, token)
                t.skipWhitespaces()

                // Parse separator if present
                if sep != "" </span><span class="cov0" title="0">{
                        t.advance(len(sep))
                        t.skipWhitespaces()

                        // Schema must follow separator
                        if schema == "" </span><span class="cov0" title="0">{
                                err := NewSyntaxError(ErrorSchemaMissing, "Missing schema definition after section separator. Expected schema name starting with '$'.", t.currentPosition())
                                errToken := NewErrorToken(err, "", t.currentPosition())
                                t.tokens = append(t.tokens, errToken)
                                return
                        }</span>
                }
        }

        // Parse schema if present
        <span class="cov8" title="1">if schema != "" </span><span class="cov0" title="0">{
                start := t.currentPosition()
                t.advance(len(schema))
                end := t.currentPosition()
                token := NewTokenWithSubType(TokenString, string(TokenSectionSchema), schema, schema, NewPositionRange(start.Start, end.Start))
                t.tokens = append(t.tokens, token)
                t.skipWhitespaces()
        }</span>
}

// mergeTokens merges two tokens into one (used when number is followed by open string).
func (t *Tokenizer) mergeTokens(first, second *Token, spaces string) *Token <span class="cov0" title="0">{
        raw := first.Raw + spaces + second.Raw
        value := first.Raw + spaces + fmt.Sprint(second.Value)
        pos := NewPositionRange(first.Position.Start, second.Position.End)
        return NewTokenWithSubType(TokenString, "OPEN_STRING", value, raw, pos)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
